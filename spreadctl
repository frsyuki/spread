#!/usr/bin/env ruby
#
#  SpreadOSD
#  Copyright (C) 2010  FURUHASHI Sadayuki
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Affero General Public License as
#  published by the Free Software Foundation, either version 3 of the
#  License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Affero General Public License for more details.
#
#  You should have received a copy of the GNU Affero General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

require 'spread'

include SpreadOSD

def usage
	puts "Usage: #{File.basename($0)} <address:port> <command> [options]"
	puts "command:"
	puts "   nodes                  get active nodes"
	puts "   new_nodes              get not-attached nodes"
	puts "   fault_nodes            get fault nodes"
	puts "   attach_nodes <nid...>  attach new nodes"
	puts "   detach_nodes <nid...>  detach fault nodes"
	puts "   recover_nodes <nid...> recover fault nodes"
	puts "   replset                get replset infomation"
	puts "   add_obj <path> <val>   add new object"
	puts "   get_obj <path>         get the object"
	puts "   set_attr <path> <json> set attributes to the object"
	puts "   get_attr <path>        get attributes of the object"
	puts "   get_child <path>       get child keys"
	exit 1
end

if ARGV.length < 2
	usage
end

addr = ARGV.shift
host, port = addr.split(':', 2)
$addr = Address.new(host, port)

cmd = ARGV.shift

module TArray
	class Template < Array
		def initialize
			super()
		end
		def from_msgpack(obj)
			obj.each {|v|
				push self.class::CLASS.new.from_msgpack(v)
			}
			self
		end
	end
	def self.new(klass)
		Class.new(Template) do
			const_set(:CLASS, klass)
		end
	end
end

def cmd_args(n)
	if n < 0
		return ARGV
	end
	usage if ARGV.length != n
	ARGV.map! {|ar| ar == '-' ? $stdin.read : ar }
	if n == 1
		ARGV[0]
	else
		ARGV
	end
end

def call(klass, *args)
	result = $net.get_session($addr).call(*args)
	if klass && result
		klass.new.from_msgpack(result)
	else
		result
	end
end

case cmd
when "nodes"
	cmd_args(0)
	pp call(NodeList, :get_node_list)

when "fault_nodes"
	cmd_args(0)
	pp call(FaultInfo, :get_fault_info)

when "new_nodes"
	cmd_args(0)
	pp call(TArray.new(Node), :get_new_nodes)

when "attach_nodes"
	nids = cmd_args(-1)
	nids.map! {|nid| nid.to_i }
	pp call(nil, :attach_node, nids)

when "detach_nodes"
	nids = cmd_args(-1)
	nids.map! {|nid| nid.to_i }
	pp call(nil, :detach_node, nids)

when "recover_nodes"
	nids = cmd_args(-1)
	nids.map! {|nid| nid.to_i }
	pp call(nil, :recover_node, nids)

when "replset"
	cmd_args(0)
	pp call(ReplsetInfo, :get_replset_info)

when "add_obj"
	path, val = cmd_args(2)
	key_seq = path.split('/')
	attributes = {}
	pp call(nil, :add_object, key_seq, attributes, val)

when "get_obj"
	path = cmd_args(1)
	key_seq = path.split('/')
	pp call(nil, :get_object, key_seq)

when "get_attr"
	path = cmd_args(1)
	key_seq = path.split('/')
	pp call(nil, :get_object_attributes, key_seq)

when "set_attr"
	path, val = cmd_args(2)
	key_seq = path.split('/')
	attributes = JSON.parse(val)
	pp call(nil, :set_object_attributes, key_seq, attributes)

when "get_child"
	path = cmd_args(1)
	key_seq = path.split('/')
	pp call(nil, :get_child_keys, key_seq, 0, 1000)

else
	puts "unknown command #{cmd}"
	puts ""
	usage
end

